name: "test:sub-agents"
description: "Test workflow demonstrating sub-agent parallel execution with complex computed fields"
version: "1.0.0"

inputs:
  git_output:
    type: "string"
    description: "Raw git output with file paths (newline separated)"
    required: false
    default: "src/test.ts\nsrc/another.js\nREADME.md\nnode_modules/test.js\n.git/config\ndist/build.js"
  
  file_list:
    type: "array"
    description: "Direct list of files to process (alternative to git_output)"
    required: false
    default: []

default_state:
  raw:
    git_output: ""
    file_list: []
    results: {}
    processed_count: 0

# Complex computed state fields similar to code-standards:enforce
state_schema:
  computed:
    # First: Parse git output into individual files
    changed_files:
      from: "raw.git_output"
      transform: "input.split('\\n').filter(line => line.trim() !== '')"
    
    # Second: Filter for code files only, excluding certain directories
    code_files:
      from: "computed.changed_files"
      transform: |
        input.filter(file => {
          const codeExts = ['.py', '.pyi', '.ts', '.tsx', '.js', '.jsx', '.java', '.cpp', '.cc', '.cxx', '.h', '.hpp', '.cs', '.rb'];
          const excludeDirs = ['node_modules', '__pycache__', '.git', 'dist', 'build', 'target', 'bin', 'obj', 'out', '.venv', 'venv', 'env', '.pytest_cache', '.mypy_cache', 'vendor'];
          const parts = file.split('/');
          const hasExcluded = parts.some(part => excludeDirs.includes(part));
          const isCode = codeExts.some(ext => file.endsWith(ext));
          return !hasExcluded && isCode;
        })
    
    # Third: Fallback to direct file list if no git output
    final_files:
      from: ["computed.code_files", "raw.file_list"]
      transform: "input[0].length > 0 ? input[0] : input[1]"
    
    # Statistics
    total_files:
      from: "computed.final_files"
      transform: "input.length"
    
    has_files:
      from: "computed.final_files"
      transform: "input.length > 0"
    
    typescript_files:
      from: "computed.final_files"
      transform: "input.filter(f => f.endsWith('.ts') || f.endsWith('.tsx'))"
    
    javascript_files:
      from: "computed.final_files"
      transform: "input.filter(f => f.endsWith('.js') || f.endsWith('.jsx'))"
    
    # Processing status
    all_processed:
      from: ["raw.processing_results", "computed.final_files"]
      transform: "Object.keys(input[0] || {}).length === input[1].length"
    
    failed_files:
      from: "raw.processing_results"
      transform: "Object.entries(input || {}).filter(([_, result]) => !result.success).map(([file, _]) => file)"

steps:
  # Step 1: Initialize with git output or file list
  - id: "initialize_git_output"
    type: "state_update"
    path: "raw.git_output"
    value: "{{ git_output }}"

  - id: "initialize_file_list"
    type: "state_update"
    path: "raw.file_list"
    value: "{{ file_list }}"

  # Step 2: Show what files were found
  - id: "files_found_message"
    type: "user_message"
    message: |
      Found {{ computed.total_files }} files to process:
      - Changed files: {{ computed.changed_files.length }}
      - Code files: {{ computed.code_files.length }}
      - TypeScript files: {{ computed.typescript_files.length }}
      - JavaScript files: {{ computed.javascript_files.length }}
      - Final list: {{ computed.final_files.slice(0, 5).join(', ') }}{{ computed.final_files.length > 5 ? '...' : '' }}

  # Step 3: Check if we have files to process
  - id: "check_has_files"
    type: "conditional"
    condition: "{{ computed.has_files }}"
    then_steps:
      - id: "start_processing_message"
        type: "user_message"
        message: "Starting parallel processing of {{ computed.total_files }} files..."
    else_steps:
      - id: "no_files_message"
        type: "user_message"
        message: "No files found to process. Workflow complete."
      - id: "exit_early"
        type: "break"

  # Step 4: Process files in parallel using computed.final_files
  - id: "process_files_parallel"
    type: "parallel_foreach"
    items: "{{ computed.final_files }}"
    max_parallel: 3
    sub_agent_task: "process_file"

  # Step 5: Finalize with computed field reference
  - id: "finalize"
    type: "state_update"
    path: "raw.processed_count"
    value: "{{ computed.total_files }}"

  - id: "completion_message"
    type: "user_message"
    message: |
      âœ… Processing complete!
      - Total files: {{ computed.total_files }}
      - Processed: {{ raw.processed_count }}
      - Failed: {{ computed.failed_files.length }}

sub_agent_tasks:
  process_file:
    description: "Process a single file through comprehensive code standards enforcement"
    inputs:
      file_path:
        type: "string"
        description: "Path to the file to process"
        required: true
      
      max_attempts:
        type: "number"
        description: "Maximum fix attempts"
        required: false
        default: 5

    default_state:
      raw:
        attempt_number: 0
        success: false
        last_error: ""
        step_results:
          hints: null
          lint: null
          typescript: null

    state_schema:
      computed:
        is_typescript_file:
          from: "{{ file_path }}"
          transform: "input.endsWith('.ts') || input.endsWith('.tsx')"

        hints_completed:
          from: "raw.step_results"
          transform: "input.hints !== null && input.hints.success === true"

        lint_completed:
          from: "raw.step_results"
          transform: "input.lint !== null && input.lint.success === true"

        typescript_completed:
          from: ["raw.step_results", "computed.is_typescript_file"]
          transform: "!input[1] || (input[0].typescript !== null && input[0].typescript.success === true)"

        all_steps_completed:
          from: ["computed.hints_completed", "computed.lint_completed", "computed.typescript_completed"]
          transform: "input[0] && input[1] && input[2]"

        can_continue:
          from: ["raw.attempt_number", "{{ max_attempts }}", "computed.all_steps_completed"]
          transform: "input[0] < input[1] && !input[2]"

    steps:
      # Main processing loop matching original prompt template logic
      - id: "standards_enforcement_loop"
        type: "while_loop"
        condition: "{{ computed.can_continue }}"
        max_iterations: 5
        body:
          - id: "start_attempt"
            type: "state_update"
            path: "raw.attempt_number"
            value: "{{ raw.attempt_number + 1 }}"

          - id: "attempt_message"
            type: "user_message"
            message: "Starting attempt {{ raw.attempt_number }} for {{ file_path }}"

          # Step 1: Get hints for the file
          - id: "get_hints_step"
            type: "conditional"
            condition: "{{ !computed.hints_completed }}"
            then_steps:
              - id: "get_hints"
                type: "mcp_call"
                tool: "hints_for_files"
                parameters:
                  file_paths: ["{{ file_path }}"]
                store_result: "hints_output"

              - id: "process_hints_result"
                type: "conditional"
                condition: "{{ hints_output.success }}"
                then_steps:
                  - id: "store_hints_success"
                    type: "state_update"
                    path: "raw.step_results.hints"
                    value:
                      success: true
                      completed_at: "{{ raw.attempt_number }}"
                else_steps:
                  - id: "store_hints_failure"
                    type: "state_update"
                    path: "raw.step_results.hints"
                    value:
                      success: false
                      error: "Failed to get hints"
                      attempt: "{{ raw.attempt_number }}"

          # Step 2: Run linting
          - id: "lint_step"
            type: "conditional"
            condition: "{{ computed.hints_completed && !computed.lint_completed }}"
            then_steps:
              - id: "run_lint"
                type: "mcp_call"
                tool: "lint_project"
                parameters:
                  target_files: ["{{ file_path }}"]
                  use_eslint_standards: true
                store_result: "lint_output"

              - id: "process_lint_results"
                type: "conditional"
                condition: "{{ lint_output.success && (!lint_output.data.errors || lint_output.data.errors.length === 0) }}"
                then_steps:
                  - id: "lint_success"
                    type: "state_update"
                    path: "raw.step_results.lint"
                    value:
                      success: true
                      completed_at: "{{ raw.attempt_number }}"
                else_steps:
                  - id: "lint_partial"
                    type: "state_update"
                    path: "raw.step_results.lint"
                    value:
                      success: false
                      errors: "{{ lint_output.data.errors.length || 0 }}"
                      attempt: "{{ raw.attempt_number }}"

          # Step 3: TypeScript check (if applicable)
          - id: "typescript_step"
            type: "conditional"
            condition: "{{ computed.is_typescript_file && computed.lint_completed && !computed.typescript_completed }}"
            then_steps:
              - id: "run_typescript"
                type: "mcp_call"
                tool: "check_typescript"
                parameters:
                  file_paths: ["{{ file_path }}"]
                store_result: "typescript_output"

              - id: "process_typescript_results"
                type: "conditional"
                condition: "{{ typescript_output.success && (!typescript_output.data.errors || typescript_output.data.errors.length === 0) }}"
                then_steps:
                  - id: "typescript_success"
                    type: "state_update"
                    path: "raw.step_results.typescript"
                    value:
                      success: true
                      completed_at: "{{ raw.attempt_number }}"
                else_steps:
                  - id: "typescript_partial"
                    type: "state_update"
                    path: "raw.step_results.typescript"
                    value:
                      success: false
                      errors: "{{ typescript_output.data.errors.length || 0 }}"
                      attempt: "{{ raw.attempt_number }}"

          # Auto-complete TypeScript for non-TS files
          - id: "skip_typescript_for_non_ts"
            type: "conditional"
            condition: "{{ !computed.is_typescript_file && computed.lint_completed }}"
            then_steps:
              - id: "auto_complete_typescript"
                type: "state_update"
                path: "raw.step_results.typescript"
                value:
                  success: true
                  skipped: true
                  reason: "Not a TypeScript/JavaScript file"

      # Final result processing
      - id: "final_result_processing"
        type: "conditional"
        condition: "{{ computed.all_steps_completed }}"
        then_steps:
          - id: "mark_final_success"
            type: "state_update"
            path: "raw.success"
            value: true
        else_steps:
          - id: "mark_final_failure"
            type: "state_update"
            path: "raw.last_error"
            value: "Failed to complete all standards checks after {{ raw.attempt_number }} attempts"