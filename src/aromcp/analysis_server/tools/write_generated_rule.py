"""
Write a generated ESLint rule to file.

This tool writes AI-generated ESLint rules to the project's generated rules directory.
"""

import os
import json
from pathlib import Path
from typing import Any

from fastmcp import FastMCP
from ...utils.json_parameter_middleware import json_convert
from ...filesystem_server._security import get_project_root, validate_file_path


def write_generated_rule_impl(
    rule_content: str,
    rule_id: str,
    output_dir: str = ".aromcp/generated-rules",
    project_root: str | None = None
) -> dict[str, Any]:
    """Write a generated ESLint rule to file.
    
    Args:
        rule_content: The ESLint rule JavaScript content
        rule_id: Unique identifier for the rule
        output_dir: Directory to write generated rules
        project_root: Project root directory (auto-resolved if None)
        
    Returns:
        Dict with write operation results
    """
    if project_root is None:
        project_root = get_project_root()
        
    try:
        # Validate inputs
        if not rule_content or not rule_content.strip():
            return {"error": {"code": "INVALID_INPUT", "message": "Rule content cannot be empty"}}
            
        if not rule_id or not _is_valid_rule_id(rule_id):
            return {"error": {"code": "INVALID_INPUT", "message": "Invalid rule ID format"}}
            
        # Create output directory structure
        output_path = os.path.join(project_root, output_dir)
        rules_path = os.path.join(output_path, "rules")
        os.makedirs(rules_path, exist_ok=True)
        
        # Validate output directory
        validation_result = validate_file_path(rules_path, project_root)
        if not validation_result["valid"]:
            return {"error": {"code": "PERMISSION_DENIED", "message": validation_result["error"]}}
            
        # Write rule file
        rule_filename = f"{rule_id}.js"
        rule_file_path = os.path.join(rules_path, rule_filename)
        
        # Add standard ESLint rule header
        rule_with_header = _add_rule_header(rule_content, rule_id)
        
        with open(rule_file_path, 'w', encoding='utf-8') as f:
            f.write(rule_with_header)
            
        # Get file stats
        file_stats = os.stat(rule_file_path)
        
        return {
            "data": {
                "rule_id": rule_id,
                "file_path": os.path.join(output_dir, "rules", rule_filename),
                "absolute_path": rule_file_path,
                "file_size": file_stats.st_size,
                "created_at": _get_timestamp(),
                "success": True
            }
        }
        
    except Exception as e:
        return {"error": {"code": "OPERATION_FAILED", "message": f"Failed to write rule: {str(e)}"}}


def _is_valid_rule_id(rule_id: str) -> bool:
    """Validate rule ID format."""
    import re
    # Rule ID should be lowercase with hyphens, no special characters
    return bool(re.match(r'^[a-z0-9-]+$', rule_id)) and len(rule_id) > 0


def _add_rule_header(rule_content: str, rule_id: str) -> str:
    """Add standard ESLint rule header to generated content."""
    header = f"""/**
 * ESLint Rule: {rule_id}
 * Generated by AroMCP Code Analysis Tools
 * Generated at: {_get_timestamp()}
 */

"""
    return header + rule_content


def _get_timestamp() -> str:
    """Get current timestamp in ISO format."""
    from datetime import datetime
    return datetime.now().isoformat()


def register_write_generated_rule(mcp: FastMCP):
    """Register the write_generated_rule tool with FastMCP."""
    
    @mcp.tool
    @json_convert
    def write_generated_rule(
        rule_content: str,
        rule_id: str,
        output_dir: str = ".aromcp/generated-rules",
        project_root: str | None = None
    ) -> dict[str, Any]:
        """Write a generated ESLint rule to file.
        
        Args:
            rule_content: The ESLint rule JavaScript content
            rule_id: Unique identifier for the rule
            output_dir: Directory to write generated rules
            project_root: Project root directory (auto-resolved if None)
            
        Returns:
            Dict with write operation results
        """
        return write_generated_rule_impl(rule_content, rule_id, output_dir, project_root)